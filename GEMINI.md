
# Gemini Project Analysis: nuxt-flux

This document outlines the key aspects of the `nuxt-flux` project to provide context for future development and maintenance.

## Project Overview

This is a [Nuxt.js](https://nuxt.com/) application, a framework for building server-side rendered (SSR) and static websites with [Vue.js](https://vuejs.org/). The project utilizes a modern tech stack, including:

- **UI Framework:** [PrimeVue](https://primevue.org/) with a custom theme, along with [Tailwind CSS](https://tailwindcss.com/) for utility-first styling.
- **State Management:** [Pinia](https://pinia.vuejs.org/) for centralized state management.
- **Database ORM:** [Prisma](https://www.prisma.io/) for database access and management.
- **Authentication:** [Auth.js](https://authjs.dev/) (formerly NextAuth.js) for handling user authentication.
- **Testing:** [Vitest](https://vitest.dev/) for unit and component testing.
- **Linting & Formatting:** [ESLint](https://eslint.org/) and [Prettier](https://prettier.io/) for code quality and consistency.
- **Data Visualization:** [D3.js](https://d3js.org/) is included, likely for the `ForceGraph.vue` component.
- **AI:** The `@google/generative-ai` package is included, indicating the use of Google's generative AI models.

## Project Structure

The project follows a standard Nuxt.js directory structure:

- `assets/`: Contains unscoped files like stylesheets, fonts, and images.
- `components/`: Houses reusable Vue components.
- `composables/`: Stores reusable Vue composables (functions).
- `layouts/`: Defines the layouts for different pages.
- `middleware/`: Contains route middleware.
- `pages/`: Represents the application's routes and views.
- `plugins/`: For adding Vue plugins.
- `prisma/`: Contains the Prisma schema and database migrations.
- `public/`: For static assets that are publicly accessible.
- `server/`: For server-side API routes and middleware.
- `services/`: Likely contains business logic and services that interact with the server and database.
- `store/`: For Pinia state management stores.
- `test/`: Contains tests for the application.
- `types/`: For TypeScript type definitions.
- `utils/`: For utility functions.

## Development Workflow

### Getting Started

1.  Install dependencies: `pnpm install`
2.  Run the development server: `pnpm dev`

### Key Scripts

- `pnpm dev`: Starts the development server with hot-reloading.
- `pnpm build`: Builds the application for production.
- `pnpm test`: Runs the test suite using Vitest.
- `pnpm lint`: Lints the codebase for errors.
- `pnpm format`: Formats the code using Prettier.
- `pnpm db:studio:local`: Opens Prisma Studio for the local database.
- `pnpm db:migrate:local`: Applies database migrations to the local database.

### Environment Variables

The project uses `.env` files for environment variables. A `.env.example` file is provided as a template. The `dev:local` and `dev:prod` scripts handle copying the appropriate `.env` file.

## Architectural Notes

- The application uses a combination of server-side rendering (SSR) and client-side logic.
- The `server/` directory contains API endpoints that the frontend can call.
- Authentication is handled by Auth.js, with a `auth.global.ts` middleware to protect routes.
- The use of Prisma suggests a relational database is used for data persistence.
- The `ForceGraph.vue` component and the `d3` dependency indicate that data visualization is a key feature of the application.
- The presence of `@google/generative-ai` suggests that the application integrates with Google's AI services.

## Core Functionality

The application, "Nuxt-Flux," is a tool for creative exploration and image generation, centered around a "dream" metaphor. Users interact with a force-directed graph of concepts (tags) to generate unique prompts, which are then used to create images with a generative AI model (Google's Gemini).

### Key Features

1.  **Dream Sessions:** Each "dream" is a persistent session that stores the state of the concept graph, generated prompts, and resulting images. Users can create new dreams, load existing ones, and view their gallery of generated images.

2.  **Concept Graph (`ForceGraph.vue`):** The primary user interface is a D3.js-powered force-directed graph.
    *   **Nodes:** Represent concepts or "tags" that can be selected or deselected.
    *   **Zones:** The graph is divided into zones (e.g., "Subject," "Style," "Composition"), allowing users to focus on different aspects of their creation.
    *   **Interaction:** Users can click nodes to select/deselect them, and right-click to access a context menu for more advanced actions (e.g., generating related concepts).

3.  **Prompt Generation (`TagCloud.vue`, `promptGenerationService.ts`):**
    *   As users select tags in the graph, a prompt is automatically generated by combining the text of the selected tags.
    *   Users can switch to a manual mode to write their own prompts.

4.  **Image Generation (`imageGenerationService.ts`, `gemini-image.ts`):**
    *   Users can click a "Generate Image" button to send the current prompt to the backend.
    *   The backend uses the Google Gemini API to generate an image from the prompt.
    *   The generated image is displayed in the UI and saved to the user's gallery, associated with the current dream.

5.  **Image Gallery & Snapshots (`gallery.vue`, `ImageStrip.vue`):**
    *   A gallery page displays all images a user has generated.
    *   Within a dream session, an `ImageStrip` component shows the history of generated images for that dream.
    *   **Snapshots:** Each generated image stores a "snapshot" of the graph state at the moment of generation. Users can click an image in the strip to load that snapshot, effectively rewinding the graph to a previous state.

6.  **State Management (`tagStore.ts`):**
    *   Pinia is used for global state management. The `tagStore` is the central hub for the application's state, managing:
        *   The current set of tags and their properties (selection, position, etc.).
        *   The currently focused zone.
        *   The generated prompt and image URL.
        *   The loaded dream's ID and unsaved changes.
        *   Session state for stashing and restoring when viewing snapshots.

7.  **Backend API (`server/api/`):**
    *   A set of API endpoints handle the application's backend logic:
        *   `/api/dreams`: For creating, reading, and updating dreams.
        *   `/api/gemini`: A proxy to the Google Gemini API for text generation.
        *   `/api/gemini-image`: A dedicated endpoint for image generation.
        *   `/api/auth`: Handles user authentication.

### User Flow

1.  A user starts by creating a **new dream** or loading an existing one.
2.  They interact with the **concept graph**, selecting tags to build a creative idea.
3.  The application **generates a prompt** based on their selections.
4.  The user **generates an image** from the prompt.
5.  The new image appears in the **image strip**. The user can then:
    *   Continue modifying the graph to generate more images.
    *   Click a previous image to **load its snapshot** and explore a different creative path from that point.
6.  The user can **save their dream session** at any time, preserving the graph state and all associated data.
