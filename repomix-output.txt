This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.ai/
  blueprints/
    flux-with-replicate.md
    supabase-drizzle-actions.md
  codex/
    codex.md
    learn.md
    split-codex.md
  lib/
    nuqs.md
  plugins/
    v0.md
  rules/
    code-tutor.md
    mckay.md
  session/
    end-session.md
    start-session.md
  snippets/
    create-snippet.md
    efc.md
    shadcn.md
  status/
    2024-10-08.md
    2024-11-11.md
    2024-12-11.md
  CHANGELOG.md
  README.md
assets/
  scss/
    components/
      tag-cloud.scss
    main.scss
    variables.scss
components/
  ForceGraph.vue
  Tag.vue
  TagCloud.vue
  ZoneSelector.vue
composables/
  useForceSimulation.ts
  useLinkStyling.ts
  useNodeStyling.ts
  useZoom.ts
pages/
  index.vue
public/
  robots.txt
server/
  tsconfig.json
services/
  graphLayoutService.ts
  tagGenerationService.ts
  tagProcessingService.ts
  tagSelectionService.ts
store/
  mockTags.ts
  tagStore.ts
types/
  graph.ts
  tag.ts
.eslintrc.js
.gitignore
.prettierrc
app.vue
nuxt.config.ts
package.json
README.md
tailwind.config.js
tsconfig.json

================================================================
Files
================================================================

================
File: .ai/blueprints/flux-with-replicate.md
================
# Flux with Replicate Documentation

Use this guide to setup generating images with Flux and Replicate.

Write the complete code for every step. Do not get lazy. Write everything that is needed.

Your goal is to completely finish the feature.

## Helpful Links

- [Replicate](https://replicate.com)
- [Flux Schnell](https://replicate.com/black-forest-labs/flux-schnell?input=nodejs)

## Required Environment Variables

Make sure the user has the following environment variables set:

- REPLICATE_API_TOKEN=

## Install Replicate

Make sure the user has the Replicate package installed:

```bash
npm install replicate
```

## Setup Steps

### Create a Replicate Client

This file should go in `/lib/replicate.ts`

```ts
import Replicate from "replicate";

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN,
});
```

### Create a Server Action

This file should go in `/actions/replicate-actions.ts`

```ts
"use server";

import replicate from "@/lib/replicate";

export async function generateFluxImage(prompt: string) {
const input = {
prompt: prompt,
num_outputs: 1,
aspect_ratio: "1:1",
output_format: "webp",
output_quality: 80
};

const output = await http://replicate.run("black-forest-labs/flux-schnell", { input });
return output;
}
```

### Build the Frontend

This file should go in `/app/flux/page.tsx`.

- Create a form that takes a prompt
- Create a button that calls the server action
- Have a nice ui for when the image is blank or loading
- Display the image that is returned
- Have a button to generate a new image
- Have a button to download the image

================
File: .ai/blueprints/supabase-drizzle-actions.md
================
# Backend Setup Instructions

Use this guide to setup the backend for this project.

It uses Supabase, Drizzle ORM, and Server Actions.

Write the complete code for every step. Do not get lazy. Write everything that is needed.

Your goal is to completely finish the backend setup.

## Helpful Links

If the user gets stuck, refer them to the following links:

- [Supabase Docs](https://supabase.com)
- [Drizzle Docs](https://orm.drizzle.team/docs/overview)
- [Drizzle with Supabase Quickstart](https://orm.drizzle.team/learn/tutorials/drizzle-with-supabase)

## Install Libraries

Make sure the user knows to install the following libraries:

```bash
npm i drizzle-orm dotenv postgres
npm i -D drizzle-kit
```

## Setup Steps

- [ ] Create a `/db` folder in the root of the project

- [ ] Create a `/types` folder in the root of the project

- [ ] Add a `drizzle.config.ts` file to the root of the project with the following code:

```ts
import { config } from "dotenv";
import { defineConfig } from "drizzle-kit";

config({ path: ".env.local" });

export default defineConfig({
  schema: "./db/schema/index.ts",
  out: "./db/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

- [ ] Add a file called `db.ts` to the `/db` folder with the following code:

```ts
import { config } from "dotenv";
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { exampleTable } from "./schema";

config({ path: ".env.local" });

const schema = {
  exampleTable,
};

const client = postgres(process.env.DATABASE_URL!);

export const db = drizzle(client, { schema });
```

- [ ] Create 2 folders in the `/db` folder:

- `/schema`
- Add a file called `index.ts` to the `/schema` folder
- `/queries`

- [ ] Create an example table in the `/schema` folder called `example-schema.ts` with the following code:

```ts
import { integer, pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";

export const exampleTable = pgTable("example", {
  id: uuid("id").defaultRandom().primaryKey(),
  name: text("name").notNull(),
  age: integer("age").notNull(),
  email: text("email").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()),
});

export type InsertExample = typeof exampleTable.$inferInsert;
export type SelectExample = typeof exampleTable.$inferSelect;
```

- [ ] Export the example table in the `/schema/index.ts` file like so:

```ts
export * from "./example-schema";
```

- [ ] Create a new file called `example-queries.ts` in the `/queries` folder with the following code:

```ts
"use server";

import { eq } from "drizzle-orm";
import { db } from "../db";
import { InsertExample, SelectExample } from "../schema/example-schema";
import { exampleTable } from "./../schema/example-schema";

export const createExample = async (data: InsertExample) => {
try {
const [newExample] = await db.insert(exampleTable).values(data).returning();
return newExample;
} catch (error) {
console.error("Error creating example:", error);
throw new Error("Failed to create example");
}
};

export const getExampleById = async (id: string) => {
try {
const example = await db.query.exampleTable.findFirst({
where: eq(http://exampleTable.id, id)
});
if (!example) {
throw new Error("Example not found");
}
return example;
} catch (error) {
console.error("Error getting example by ID:", error);
throw new Error("Failed to get example");
}
};

export const getAllExamples = async (): Promise<SelectExample[]> => {
return db.query.exampleTable.findMany();
};

export const updateExample = async (id: string, data: Partial<InsertExample>) => {
try {
const [updatedExample] = await db.update(exampleTable).set(data).where(eq(http://exampleTable.id, id)).returning();
return updatedExample;
} catch (error) {
console.error("Error updating example:", error);
throw new Error("Failed to update example");
}
};

export const deleteExample = async (id: string) => {
try {
await db.delete(exampleTable).where(eq(http://exampleTable.id, id));
} catch (error) {
console.error("Error deleting example:", error);
throw new Error("Failed to delete example");
}
};
```

- [ ] In `package.json`, add the following scripts:

```json
"scripts": {
"db:generate": "npx drizzle-kit generate",
"db:migrate": "npx drizzle-kit migrate"
}
```

- [ ] Run the following command to generate the tables:

```bash
npm run db:generate
```

- [ ] Run the following command to migrate the tables:

```bash
npm run db:migrate
```

- [ ] Create a folder called `/actions` in the root of the project for server actions

- [ ] Create folder called `/types` in the root of the project for shared types

- [ ] Create a file called `action-types.ts` in the `/types/actions` folder for server action types with the following code:

- [ ] Create file called `/types/index.ts` and export all the types from the `/types` folder like so:

```ts
export * from "./action-types";
```

- [ ] Create a file called `example-actions.ts` in the `/actions` folder for the example table's actions:

```ts
"use server";

import {
  createExample,
  deleteExample,
  getAllExamples,
  getExampleById,
  updateExample,
} from "@/db/queries/example-queries";
import { InsertExample } from "@/db/schema/example-schema";
import { ActionState } from "@/types";
import { revalidatePath } from "next/cache";

export async function createExampleAction(
  data: InsertExample
): Promise<ActionState> {
  try {
    const newExample = await createExample(data);
    revalidatePath("/examples");
    return {
      status: "success",
      message: "Example created successfully",
      data: newExample,
    };
  } catch (error) {
    return { status: "error", message: "Failed to create example" };
  }
}

export async function getExampleByIdAction(id: string): Promise<ActionState> {
  try {
    const example = await getExampleById(id);
    return {
      status: "success",
      message: "Example retrieved successfully",
      data: example,
    };
  } catch (error) {
    return { status: "error", message: "Failed to get example" };
  }
}

export async function getAllExamplesAction(): Promise<ActionState> {
  try {
    const examples = await getAllExamples();
    return {
      status: "success",
      message: "Examples retrieved successfully",
      data: examples,
    };
  } catch (error) {
    return { status: "error", message: "Failed to get examples" };
  }
}

export async function updateExampleAction(
  id: string,
  data: Partial<InsertExample>
): Promise<ActionState> {
  try {
    const updatedExample = await updateExample(id, data);
    revalidatePath("/examples");
    return {
      status: "success",
      message: "Example updated successfully",
      data: updatedExample,
    };
  } catch (error) {
    return { status: "error", message: "Failed to update example" };
  }
}

export async function deleteExampleAction(id: string): Promise<ActionState> {
  try {
    await deleteExample(id);
    revalidatePath("/examples");
    return { status: "success", message: "Example deleted successfully" };
  } catch (error) {
    return { status: "error", message: "Failed to delete example" };
  }
}
```

```ts
export type ActionState = {
  status: "success" | "error";
  message: string;
  data?: any;
};
```

- [ ] Implement the server actions in the `/app/page.tsx` file to allow for manual testing.

- [ ] The backend is now setup.

================

================
File: .ai/README.md
================
# .ai

This folder contains AI-assisted development tools for improving code quality and consistency.

## How to use?

- Click on the "Use this template" button
- Create a `.ai` folder in your repository
- Move the content of this template into the `.ai` folder

## Codex

### Files

- [codex.md](codex/codex.md): AI Codex - A repository of learnings and errors.
- [learn.md](codex/learn.md): AI Learn - Protocol for updating the AI Codex.

### Usage

1. Review the Codex: [codex.md](codex/codex.md) (silent load, no output)
2. Update the Codex: [learn.md](codex/learn.md)

### Important Note

[codex.md](codex/codex.md) should be added to the context of every chat:

- For regular chats: Use the plus button at the top of the chat to add the file.
- For Composers: Add the file to a Project Composer so all Composers created in that project will automatically have the file.

### Structure

The [Codex](codex/codex.md) is divided into two main sections:

1. Errors: Mistakes made and how to prevent them.
2. Learnings: Insights gained and their applications.

Each entry includes context, description, correction/application, and related entries.

## Snippets

Snippets include code templates that AI can use to generate or refactor code. They help in writing shorter prompts for better results.

- [create-snippet.md](snippets/create-snippet.md): Prompt for creating new snippets

## Session

- [start-session.md](session/start-session.md): Initiates a new AI session
- [end-session.md](session/end-session.md): Concludes the current AI session

Session files create a "memory layer" for the AI across multiple interactions, enabling contextual awareness and adaptive assistance.

Key benefits:

- Maintains project context between sessions
- Reduces repetition of project details
- Provides consistent guidance aligned with project direction

Usage:

1. End a session: Use [@end-session](session/end-session.md) command
2. Start a new session: Use [@start-session](session/start-session.md) command

The AI will generate and read status files in [status](status) to maintain project continuity.

## Blueprints

Blueprints are comprehensive guides for implementing specific technical architectures or project setups. They provide step-by-step instructions for installing, configuring, and integrating various technologies to create a functional foundation for your project.

- [supabase-drizzle-actions.md](blueprints/supabase-drizzle-actions.md): Backend architecture with Supabase, Drizzle ORM, and Server Actions
- [flux-with-replicate.md](blueprints/flux-with-replicate.md): Image generation using Flux and Replicate

## Libraries

- [lib](lib): Contains documentation examples for library usage

## Plugins

### v0

- [v0.dev](https://v0.dev/) is a tool for generating React components from screenshots and chat. Currently, they don't have a Cursor plugin, so you can use [v0](v0/v0.md) bridging prompt.
- [v0.md](v0/v0.md): Guide for using v0.dev to generate component ideas and prompts

## Rules of AI

[Rules](rules) contains rules for default AI behavior and interaction. These rules are meant to be added to the global "Rules of AI" setting.

## Contributing

This is an open-source template. Contributions are welcome! Please add a changelog entry with your contribution.

## Note

This system is designed for AI consumption. Entries should prioritize precision and relevance over human readability

================
File: assets/scss/components/tag-cloud.scss
================
.tag-cloud {
  display: flex;
  flex-direction: column;
  padding: 0px 20px 0 20px;
  width: 100%;
}

.main-zone {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  /* Let top row dominate height, bottom row adjusts */
  grid-template-rows: minmax(0, 1fr) auto; 
  gap: 1rem; /* Increased gap for better spacing */
  width: 100%;
  height: calc(100vh - 40px); /* Account for padding */
  max-height: calc(100vh - 40px);
  box-sizing: border-box;
}

/* General styles for all containers within the grid */
.graph-container,
.image-preview-container,
.settings-container,
.prompt-area-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start; 
  min-height: 220px; 
  
  h2 {
    text-align: left;
    width: 100%;
    margin-bottom: 0.75rem; 
    color: #6d80a4;
    flex-shrink: 0;
    font-size: 1.2rem;
    font-weight: 500;
  }
  
  .zone-title {
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  }
}

/* Specific adjustments */
.graph-container {
  padding-bottom: 0rem !important;
  grid-row: 1 / 2; 
  grid-column: 1 / 2;
  overflow: hidden; /* Graph container itself should not scroll */
  .force-graph-component {
    width: 100%;
    flex-grow: 1; 
    min-height: 0; 
  }
  .zone-selector {
    /* Styles for zone selector */
    margin-top: 0.5rem;
  }
}

.image-preview-container {
  grid-row: 1 / 2; 
  grid-column: 2 / 3; 
  overflow: hidden; /* Image preview container should not scroll */
  .image-container {
    width: 100%;
    max-width: 100%;
    aspect-ratio: 4 / 3; 
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    flex-shrink: 0; 
  }
  
  .generated-image {
    max-width: 100%;
    max-height: 100%;
    border-radius: 8px;
    object-fit: contain;
  }
  
  .placeholder-container {
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    
    &::after {
      content: 'Generate an image';
      color: rgba(255, 255, 255, 0.5);
      font-style: italic;
    }
  }
}

.settings-container {
  grid-row: 2 / 3; 
  grid-column: 1 / 2; 
  overflow-y: auto; /* Allow settings to scroll if needed */
  p {
    color: #ccc;
  }
}

.prompt-area-container {
  grid-row: 2 / 3; 
  grid-column: 2 / 3; 
  justify-content: flex-start; 
  overflow-y: auto; /* Allow prompt area to scroll if needed */
  
  .prompt-box {
     /* Styles seem okay, ensure flex-grow: 1 allows it to expand/shrink */
     flex-grow: 1; 
     min-height: 100px; /* Give it some base height */
  }

  .selected-tags-display {
     /* Styles seem okay */
  }
}

.preview-zones {
  display: flex;
  justify-content: space-between;
  width: 100%;
}

.preview-zone {
  width: calc(20% - 10px);
  padding-top: 5px;
  border: 1px solid #cfcfcf;
  border-radius: 10px;
  cursor: pointer;
  transition: transform 0.2s;
  background: #fff;
  
  &:hover {
    transform: scale(1.05);
  }

  h3 {
    text-align: center;
    margin-bottom: 5px;
  }
}

.loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  font-size: 1.5rem;
}

.progress-spinner {
  .p-progressspinner-circle {
    stroke: white !important;
  }
}

/* Zone-specific button styles for SelectButton */
.zone-selector {
  margin-top: 0.5rem;
}

/* Delete everything below this point related to zone button styles */

================
File: assets/scss/main.scss
================
@use 'variables' as v;
@import 'components/tag-cloud';

:root {
  --font-family: #{v.$font-family};
  --text-color: #{v.$text-color};
  --background-color: #{v.$background-color};
  --secondary-color: #{v.$secondary-color};
}

body {
  font-family: v.$font-family;
  color: v.$text-color;
  background-color: v.$background-color;
  background-color: #8EC5FC;
  background-image: linear-gradient(62deg, #8EC5FC 0%, #E0C3FC 100%);
  background-repeat: no-repeat;
  background-attachment: fixed;
  background-size: 100% 100%;
  min-height: 100vh;
  margin: 0;
  padding: 0;
}



.glass-card {
  background: rgba(255, 255, 255, 0.3); /* semi-transparent white */
  border-radius: 16px;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px); /* for Safari */
  border: 1px solid rgba(255, 255, 255, 0.3);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
  padding: 1rem 1.5rem;
  color: white;
  transition: all 0.3s ease;
}


// .glass-card:hover {
//   background: rgba(255, 255, 255, 0.15);
//   box-shadow: 0 12px 48px rgba(0, 0, 0, 0.35);
// }

================
File: assets/scss/variables.scss
================
$font-family: 'Roboto', sans-serif;
$text-color: #474565;
$background-color: #dcdaf0;
$secondary-color: #6d80a4;

================
File: components/ForceGraph.vue
================
<template>
  <div class="force-graph-component relative" ref="container" :style="containerStyle">
    <!-- D3 SVG will be appended here -->
    
    <!-- Controls container -->
    <div class="controls-overlay absolute bottom-4 left-4 right-4 justify-between items-center">
      <!-- Slot for additional controls like zone selector -->
          <!-- Existing Zoom controls -->
      <div class="zoom-controls flex justify-end flex-col gap-2 w-7 ml-auto mb-5">
        <Button 
          @click="() => svg && zoomInFn(svg)"
          severity="secondary"
          size="small"
          class="w-7 h-7"
          aria-label="Zoom In"
        >
          +
        </Button>
        <Button 
          @click="() => svg && zoomOutFn(svg)"
          severity="secondary"
          size="small"
          class="w-7 h-7"
          aria-label="Zoom Out"
        >
          -
        </Button>
        <Button 
          @click="() => svg && resetZoomFn(svg)"
          severity="secondary"
          size="small"
          class="!w-7 !h-7"
          aria-label="Reset Zoom"
          icon="pi pi-sync"
        />
      </div>
      <div >
      <div class="additional-controls flex-grow">
        <slot name="controls"></slot>
      </div>
     </div>
   
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch, computed, onBeforeUnmount } from 'vue';
import * as d3 from 'd3';
import 'd3-transition'; // Ensure transition support is available
import { useZoom } from '~/composables/useZoom';
import { useNodeStyling } from '~/composables/useNodeStyling';
import { useLinkStyling } from '~/composables/useLinkStyling';
import { useForceSimulation } from '~/composables/useForceSimulation';
import type { GraphNode, GraphLink } from '~/types/graph';

const props = defineProps<{
  width: number;
  height: number;
  nodes: GraphNode[];
  links: GraphLink[];
}>();

const emit = defineEmits(['nodeClick', 'nodePositionsUpdated']);
const container = ref<HTMLElement | null>(null);
let svg: d3.Selection<SVGSVGElement, unknown, null, undefined> | null = null;
let linkGroup: d3.Selection<SVGGElement, unknown, null, undefined> | null = null;
let nodeGroup: d3.Selection<SVGGElement, unknown, null, undefined> | null = null;
let simulation: d3.Simulation<GraphNode, GraphLink> | null = null;

// Compute responsive container style
const containerStyle = computed(() => {
  return {
    width: '100%',
    height: '100%',
    maxWidth: '100%',
    maxHeight: '100%',
  };
});

// Use our composables
const { 
  initializeZoom, 
  zoomIn: zoomInFn, 
  zoomOut: zoomOutFn, 
  resetZoom: resetZoomFn, 
  centerOnNode, 
  zoomBehavior 
} = useZoom();

const { applyNodeStyle, getSubjectImagePath, createNodeGradients } = useNodeStyling();
const { createLinkGradient, createUniqueGradient, updateGradientPositions, applyLinkStyle } = useLinkStyling();
const { createSimulation, updateSimulation, createDragBehavior } = useForceSimulation();

onMounted(() => {
  initializeGraph();
  
  // Add resize event listener
  window.addEventListener('resize', handleResize);
});

onBeforeUnmount(() => {
  saveNodePositions();
  
  // Remove resize event listener
  window.removeEventListener('resize', handleResize);
});

// Debounced resize handler
let resizeTimeout: number | null = null;
function handleResize() {
  if (resizeTimeout) {
    window.clearTimeout(resizeTimeout);
  }
  
  resizeTimeout = window.setTimeout(() => {
    updateGraph();
  }, 250);
}

watch(
  () => [
    props.nodes.map(n => ({ id: n.id, text: n.text, size: n.size, children: n.children?.map(c => c.id) || [] })),
    props.links.map(l => ({ 
      source: (l.source as GraphNode).id,
      target: (l.target as GraphNode).id,
      value: l.value 
    }))
  ],
  (newVal, oldVal) => {
    if (JSON.stringify(newVal) !== JSON.stringify(oldVal)) {
      console.log('Graph updating due to structural change');
      updateGraph();
    }
  },
  { deep: true }
);

function initializeGraph() {
  if (!container.value) return;

  // Get container dimensions
  const containerRect = container.value.getBoundingClientRect();
  const width = containerRect.width;
  const height = containerRect.height;

  // Get center coordinates
  const centerX = width / 2;
  const centerY = height / 2;

  // Pre-position all nodes at the center before creating the SVG
  props.nodes.forEach(node => {
    // Force all nodes to start exactly at center
    node.x = centerX;
    node.y = centerY;
    node.vx = 0;
    node.vy = 0;
    
    // Fix parent nodes at center
    if (!node.parentId) {
      node.fx = centerX;
      node.fy = centerY;
    }
  });

  svg = d3.select(container.value)
    .append('svg')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('viewBox', `0 0 ${width} ${height}`)
    .attr('preserveAspectRatio', 'xMidYMid meet');

  // Create a root group for zoom
  const g = svg.append('g')
    .attr('class', 'zoom-group');

  linkGroup = g.append('g').attr('class', 'links');
  nodeGroup = g.append('g').attr('class', 'nodes');

  // Initialize SVG defs and gradients
  if (svg) {
    // Prepare defs section for gradients
    if (svg.select('defs').empty()) {
      svg.append('defs');
    }
    
    // Set up node gradients
    createNodeGradients(svg);
    
    // Set up default link gradient
    createLinkGradient(svg);
  }

  // Helper function to center camera view
  function centerView() {
    if (svg && zoomBehavior.value) {
      // Create a transform that centers the view
      // In D3, the transform origin is at (0,0), so we need to
      // translate to center of the viewport
      const scale = 1.4;
      const tx = width / 2;
      const ty = height / 2;
      
      const transform = d3.zoomIdentity
        .translate(tx, ty)
        .scale(scale)
        .translate(-centerX, -centerY);
      
      // Apply the transform without transition the first time
      svg.call(zoomBehavior.value.transform as any, transform);
    }
  }

  // Initialize zoom using the composable with proper initial transform
  initializeZoom(svg, g, 1.4);
  
  // Apply center view immediately before any simulation
  centerView();

  // Create and configure the simulation using our composable
  simulation = createSimulation(props.nodes, props.links, width, height);

  if (simulation) {
    // Set up the tick function for animation
    simulation.on('tick', () => {
      if (!svg || !nodeGroup || !linkGroup) return;

      // Update node positions
      nodeGroup.selectAll<SVGGElement, GraphNode>('g')
        .attr('transform', d => `translate(${d.x || 0},${d.y || 0})`);

      // Update link positions
      linkGroup.selectAll<SVGLineElement, GraphLink>('line')
        .attr('x1', d => (d.source as GraphNode).x || 0)
        .attr('y1', d => (d.source as GraphNode).y || 0)
        .attr('x2', d => (d.target as GraphNode).x || 0)
        .attr('y2', d => (d.target as GraphNode).y || 0);

      // Update link gradients using a non-null svg reference
      const svgEl = svg; // Capture in local variable to help TypeScript
      if (svgEl) {
        linkGroup.selectAll<SVGLineElement, GraphLink>('line').each(function(d) {
          const source = d.source as GraphNode;
          const target = d.target as GraphNode;
          
          // Update gradient positions using our composable
          updateGradientPositions(svgEl, source, target);
        });
      }
    });
    
    // First render nodes and links *before* starting animation
    updateLinks();
    updateNodes();
    
    // Now start the simulation with zero initial velocity for smooth appearance
    simulation.tick(5); // Apply a few ticks immediately to stabilize
    simulation.alpha(0.3).restart();
    
    // Release fixed positions after initial layout settles
    setTimeout(() => {
      if (simulation) {
        simulation.nodes().forEach(node => {
          if (!node.parentId) {
            node.fx = null;
            node.fy = null;
          }
        });
      }
    }, 100); // Longer delay to ensure nodes have settled before releasing
  }
}

function updateGraph() {
  if (!svg || !simulation || !container.value) return;
  
  // Get current container dimensions
  const containerRect = container.value.getBoundingClientRect();
  const width = containerRect.width;
  const height = containerRect.height;
  
  // Update the viewBox to match new dimensions
  svg.attr('viewBox', `0 0 ${width} ${height}`);
  
  // Update simulation using our composable
  simulation = updateSimulation(simulation, props.nodes, props.links, width, height);

  // Update visual elements
  updateLinks();
  updateNodes();

  // Release fixed positions after a short delay
  const selectedParent = props.nodes.find(n => n.selected && !n.parentId);
  setTimeout(() => {
    if (selectedParent) {
      selectedParent.fx = null;
      selectedParent.fy = null;
    }
  }, 300);
}

function updateLinks() {
  if (!linkGroup || !svg) return;

  const link = linkGroup.selectAll<SVGLineElement, GraphLink>('line')
    .data(props.links, d => {
      const sourceId = typeof d.source === 'object' ? (d.source as GraphNode).id : d.source;
      const targetId = typeof d.target === 'object' ? (d.target as GraphNode).id : d.target;
      return `${sourceId}-${targetId}`;
    });

  // Enter new links
  const linkEnter = link.enter()
    .append('line')
    .attr('stroke', 'url(#link-gradient)');
    
  // Apply styling to all links
  applyLinkStyle(linkEnter.merge(link));

  // Create unique gradients for each link
  const svgEl = svg; // Capture in local variable to help TypeScript
  if (svgEl) {
    linkGroup.selectAll<SVGLineElement, GraphLink>('line').each(function(d) {
      const line = d3.select(this);
      const source = d.source as GraphNode;
      const target = d.target as GraphNode;
      
      // Create unique gradient and update link to use it
      const gradientId = createUniqueGradient(svgEl, source, target);
      line.attr('stroke', `url(#${gradientId})`);
    });
  }

  // Remove old links
  link.exit().remove();
}

function updateNodes() {
  if (!nodeGroup || !simulation || !svg) return;

  // Create node gradients
  createNodeGradients(svg);

  const node = nodeGroup.selectAll<SVGGElement, GraphNode>('g')
    .data(props.nodes, d => d.id);

  // Enter new nodes
  const nodeEnter = node.enter()
    .append('g')
    .attr('class', 'node')
    .call(createDragBehavior(simulation))
    .on('click', (event, d) => {
      console.log('Node clicked:', d.id);
      emit('nodeClick', d.id);
      updateNodeSelection(d.id);
      // Center on the clicked node with smooth transition
      if (svg) {
        centerOnNode(svg, d, props.width, props.height);
      }
    })
    .on('mouseenter', function() {
      // Apply hover styling
      applyNodeStyle(d3.select(this), true, svg);
    })
    .on('mouseleave', function() {
      // Restore normal styling
      applyNodeStyle(d3.select(this), false, svg);
    });

  // Add circle background
  nodeEnter.append('circle')
    .attr('r', d => d.size / 2)
    .attr('class', 'node-circle');
  
  // We no longer add text directly here - our applyNodeStyle function handles text creation

  // Add images for Subject nodes (main parent nodes only)
  nodeEnter.filter(d => d.zone === 'Subject' && !d.parentId)
    .append('image')
    .attr('xlink:href', d => getSubjectImagePath(d.text))
    .attr('x', d => -d.size / 2)
    .attr('y', d => -d.size / 2)
    .attr('width', d => d.size)
    .attr('height', d => d.size)
    .attr('class', 'subject-node-image')
    .on('error', function() {
      // If image fails to load, just keep the circle visible as fallback
      d3.select(this).style('display', 'none');
    });

  // Remove old nodes
  node.exit().remove();

  // Apply styling to all nodes (new and existing)
  nodeGroup.selectAll<SVGGElement, GraphNode>('g')
    .each(function(d) {
      applyNodeStyle(d3.select(this), false, svg);
    });
}

function updateNodeSelection(id: string) {
  if (!nodeGroup || !svg) return;

  // Update all nodes to reset their styles first
  nodeGroup.selectAll<SVGGElement, GraphNode>('g')
    .each(function(d) {
      applyNodeStyle(d3.select(this), false, svg);
    });

  // Then specially handle the selected node
  const node = nodeGroup.selectAll<SVGGElement, GraphNode>('g')
    .filter(d => d.id === id);
    
  // Apply styling with a slight delay to create a sequential animation
  setTimeout(() => {
    // Apply styling using our composable with hover effect for additional emphasis
    applyNodeStyle(node, true, svg);
    
    // Add a subtle animation to draw attention to the circle only
    node.select('.node-circle')
      .transition()
      .duration(300)
      .attr('r', d => d.size / 2 * 1.05)
      .transition()
      .duration(300)
      .attr('r', d => d.size / 2);
      
    // Raise to front
    node.raise();
  }, 50);
}

function saveNodePositions() {
  if (!simulation) return;
  const updatedPositions = simulation.nodes().map(node => ({
    id: node.id,
    x: node.x,
    y: node.y
  }));
  console.log('Emitting updated positions:', updatedPositions);
  emit('nodePositionsUpdated', updatedPositions);
}
</script>


<style lang="scss" scoped>
.force-graph-component {
  position: relative;
  width: 100%;
  height: 100%;
  svg {
    display: block;
    width: 100%;
    height: 100%;
    border: none !important;
  }
}

.node {
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover circle.node-circle {
    stroke: rgba(255, 255, 255, 0.8);
    fill: rgba(255, 255, 255, 0.3);
    filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.4));
  }
  
  .node-circle {
    transition: all 0.3s ease;
    filter: drop-shadow(0 1px 1px rgba(0, 0, 0, 0.2));
  }
  
  .subject-node-image {
    clip-path: circle(50%);
    object-fit: cover;
    filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.3));
  }
  
  .node-text {
    font-weight: 500;
    text-shadow: 0 0 4px rgba(255, 255, 255, 0.9);
    pointer-events: none; // Prevent text from interfering with clicks
    transition: all 0.2s ease;
  }
}

.absolute { position: absolute; }
.bottom-4 { bottom: 1rem; }
.left-4 { left: 1rem; }
.right-4 { right: 1rem; }
.flex { display: flex; }
.justify-between { justify-content: space-between; }
.items-center { align-items: center; }
.gap-1 { gap: 0.25rem; }

.controls-overlay {
  z-index: 10;
  pointer-events: none;
  padding: 0 0.5rem;
}

.additional-controls,
.zoom-controls {
  pointer-events: auto;
}

.additional-controls {
  flex-grow: 1;
  overflow: hidden;
}

.additional-controls :deep(.zone-selector) {
  margin-top: 0;
  margin-bottom: 0.5rem;
  width: 100%;
  display: flex;
  justify-content: center;
  
  .p-selectbutton {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 100%;
    
    .p-button {
      margin: 2px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 500;
      padding: 0.4rem 0.8rem;
      transition: all 0.3s ease;
      
      &:hover {
        transform: translateY(-2px);
      }
    }
  }
}

.additional-controls :deep(.p-togglebutton) {
  font-size: 0.90rem !important;
  min-width: auto;
}

.zoom-controls button {
  padding: 0.4rem 0.6rem;
  min-width: auto;
  line-height: 1;
}
</style>

================
File: components/Tag.vue
================
<template>
    <div 
      :class="['tag', { 'selected': tag.selected }]" 
      :style="{ 
        fontSize: `${tag.size}px`,
        left: `${tag.x}px`,
        top: `${tag.y}px`
      }"
      @click="$emit('click')"
    >
      {{ tag.text }}
    </div>
  </template>
  
  <script setup lang="ts">
  defineProps<{
    tag: {
      id: string
      text: string
      size: number
      selected: boolean
      x: number
      y: number
    }
  }>()
  
  defineEmits<{
    (e: 'click'): void
  }>()
  </script>
  
  <style lang="scss" scoped>
  .tag {
    position: absolute;
    margin: 5px;
    padding: 5px 10px;
    border-radius: 15px;
    cursor: pointer;
    transition: all 0.3s ease;
    user-select: none;
  
    &:hover {
      transform: scale(1.1);
    }
  
    &.selected {
      background-color: #4CAF50;
      color: white;
    }
  }
  </style>

================
File: components/TagCloud.vue
================
<template>
   <div class="main-zone grid grid-cols-2 tw-gap-4">
    
    <!-- Top Left: Graph -->
    <div class="graph-container glass-card">
      <h2 class="zone-title">{{ focusedZone }}</h2>
      <ForceGraph
        :width="800"
        :height="600"
        :nodes="graphNodes"
        :links="graphLinks"
        @nodeClick="handleNodeClick"
        @nodePositionsUpdated="handleNodePositionsUpdated"
      >
        <!-- Zone selector will be moved here via slot later -->
        <template #controls>
          <div class="zone-selector-container mt-4">
            <ZoneSelector
              v-model:modelValue="selectedZone"
              :options="zoneOptions"
            />
          </div>
        </template>
      </ForceGraph>
    </div>

    <!-- Top Right: Image Preview -->
    <div class="image-preview-container glass-card">
      <h2>Image:</h2>
      <div class="image-container">
        <img
          v-if="imageUrl"
          :src="imageUrl"
          alt="Generated Image"
          class="generated-image"
        />
        <div v-else class="placeholder-container"></div>
      </div>
    </div>

    <!-- Bottom Left: Settings Placeholder -->
    <div class="settings-container glass-card">
      <h2>Settings</h2>
      <!-- Settings content will go here -->
      <p>Settings placeholder...</p>
    </div>

    <!-- Bottom Right: Prompt Area -->
    <div class="prompt-area-container glass-card">
      <div class="prompt-header flex justify-between items-start w-full">
          <h2>Generated Prompt:</h2>
          <ToggleButton 
            onLabel="Auto"
            class="px-1 py-1 h-8"
            offLabel="Manual"
            onIcon="pi pi-lock" 
            offIcon="pi pi-lock-open"
            v-model="isManualMode" 
          />
        </div>
      <div class="prompt-box w-full">
    
        
        <Textarea
          v-if="isManualMode"
          v-model="manualPrompt"
          class="manual-prompt-input text-[var(--text-color)] h-[calc(100%-10px)] w-full p-2"
          placeholder="Enter your prompt..."
        ></Textarea>
        <p class="text-[#474565]" v-else>{{ generatedPromptResult }}</p>
        
     
      </div>
      <div class="flex justify-between w-full">
        <p class="w-full !text-left text-xs selected-tags-display text-[#6d80a4]">Selected Tags: <span class="font-bold">{{ generatedPrompt}}</span></p>
        <Button 
          @click="generateImage" 
          severity="primary"
          :disabled="!(isManualMode ? manualPrompt : generatedPromptResult) || isGeneratingImage"
          class="flex items-center gap-2 flex-nowrap whitespace-nowrap px-8 py-1"
        >
          <ProgressSpinner
            v-if="isGeneratingImage"
            class="w-4 h-4 progress-spinner" 
            strokeWidth="8" 
            fill="transparent"
          />
          {{ isGeneratingImage ? 'Generating...' : 'Generate Image' }}
        </Button>
      </div>
    </div>

  </div>
</template>

<script setup lang="ts">
import { computed, ref, watch, onMounted } from 'vue';
import { useTagStore } from '~/store/tagStore';
import ForceGraph from './ForceGraph.vue';
import { useRuntimeConfig } from '#app';
import { GoogleGenerativeAI } from '@google/generative-ai';
import ZoneSelector from './ZoneSelector.vue';

const config = useRuntimeConfig();
const genAI = new GoogleGenerativeAI(config.public.GEMINI_API_KEY as string);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
const imageModel = genAI.getGenerativeModel({ 
  model: 'gemini-2.0-flash-exp-image-generation'
  // The responseModalities will be specified in the request
});

const tagStore = useTagStore();
const focusedZone = computed(() => tagStore.focusedZone);
// Create a ref using the zones array directly from the store
const zoneOptions = ref([...tagStore.zones]);
const graphNodes = computed(() => tagStore.graphNodes);
const graphLinks = computed(() => tagStore.graphLinks);

// Use ref for the selected zone and sync with the store
const selectedZone = ref(focusedZone.value);

// Watch for changes to selectedZone and update the store
watch(selectedZone, (newZone) => {
  if (newZone) {
    switchToZone(newZone);
  }
});

// Add this ref near the top of the script section with other refs
const isManualMode = ref(false)
const manualPrompt = ref('')
const imageUrl = ref('')
const generatedPromptResult = ref('')
const isGeneratingImage = ref(false)

let promptRequestId = 0
let imageRequestId = 0

const generatedPrompt = computed(() => {
  // Get primary selected tags
  const selectedPrimaryTags = tagStore.tags
    .filter(tag => tag.selected)
    .map(tag => tag.text);
  
  return  selectedPrimaryTags.join(', ')
})


// Also watch for changes in the store's zones to update options
watch(() => tagStore.zones, () => {
  zoneOptions.value = [...tagStore.zones];
}, { deep: true });

// Also watch for changes in the store's focusedZone
watch(focusedZone, (newZone) => {
  selectedZone.value = newZone;
});

// Watch for changes in the generatedPrompt computed property to trigger prompt generation
watch(generatedPrompt, () => {
  generatePrompt();
});

// Generate the prompt when the component is mounted
onMounted(() => {
  if (generatedPrompt.value) {
    generatePrompt();
  }
});

function handleNodeClick(id: string) {
  console.log('TagCloud received nodeClick:', id);
  tagStore.toggleTag(id);
}

function switchToZone(zone: string) {
  console.log(`Switching to ${zone}`);
  tagStore.setFocusedZone(zone);
}

const generateImage = async () => {
  isGeneratingImage.value = true
  const currentImageRequestId = ++imageRequestId

  const promptText = isManualMode.value ? manualPrompt.value : generatedPromptResult.value
  
  if (!promptText) {
    console.error('No prompt text available')
    isGeneratingImage.value = false
    return
  }

  try {
    console.log('Generating image with prompt:', promptText)
    
    // Create a proper request object according to the Gemini API
    const response = await imageModel.generateContent({
      contents: [
        {
          role: 'user',
          parts: [{ text: promptText }]
        }
      ],
      generationConfig: {
        // @ts-ignore - The TypeScript definitions might not be updated for this new API
        responseModalities: ['Text', 'Image']
      }
    })
    
    if (currentImageRequestId === imageRequestId) {
      const result = response.response
      
      if (result && result.candidates && result.candidates.length > 0) {
        const parts = result.candidates[0].content.parts
        
        for (const part of parts) {
          if (part.inlineData) {
            // Successfully found an image
            imageUrl.value = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`
            console.log('Image generated successfully')
            break
          } else if (part.text) {
            console.log('Generated text:', part.text)
          }
        }
      }
      
      if (!imageUrl.value) {
        console.error('No image was generated in the response')
      }
    }
  } catch (error) {
    console.error('Error generating image:', error)
    console.error('Error details:', error instanceof Error ? error.message : String(error))
  } finally {
    if (currentImageRequestId === imageRequestId) {
      isGeneratingImage.value = false
    }
  }
}

// Simple debounce function
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: ReturnType<typeof setTimeout> | null = null;
  
  return function(this: any, ...args: Parameters<T>) {
    const context = this;
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      func.apply(context, args);
      timeout = null;
    }, wait);
  };
}

const generatePrompt = debounce(async () => {
  if (isManualMode.value) return // Skip auto-generation if in manual mode
  
  const prompt = generatedPrompt.value
  if (prompt.length > 0) {
    const currentRequestId = ++promptRequestId

    const response = await model.generateContent({
      contents: [
        {
          role: 'user',
          parts: [
            {
              text: `You are creating an image prompt based on the following tags: ${prompt}. You should create prompt as much exactly matching the tags as possible, based on the tags but transformed into a prompt for an image generator, the result is a prompt for an image generator, no words before, no words after, just the prompt.`,
            },
          ],
        },
      ],
      generationConfig: {
        temperature: 0.5,
        maxOutputTokens: 1000,
      },
    })

    if (currentRequestId === promptRequestId) {
      generatedPromptResult.value = await response.response.text()
    }
  }
}, 300)

function handleNodePositionsUpdated(positions: { id: string; x: number; y: number }[]) {
  console.log('Received updated positions:', positions);
  positions.forEach(pos => {
    const tag = tagStore.tags.find(t => t.id === pos.id);
    if (tag) {
      tag.x = pos.x;
      tag.y = pos.y;
    }
  });
}
</script>

<style scoped>
/* Component-specific styles are now in assets/scss/components/tag-cloud.scss */
/* We keep this block for scoped styles as needed but don't add any until explicitly asked */
</style>

================
File: components/ZoneSelector.vue
================
<template>
  <div class="zone-selector" ref="container">
    <SelectButton 
      :modelValue="modelValue" 
      :options="options" 
      class="zone-buttons"
      @update:modelValue="$emit('update:modelValue', $event)"
    >
      <template #option="slotProps">
        <div :class="['zone-button-content', `zone-${slotProps.option.toLowerCase()}`]">
          {{ slotProps.option }}
        </div>
      </template>
    </SelectButton>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue';

const props = defineProps<{
  modelValue: string;
  options: string[];
}>();

defineEmits(['update:modelValue']);

const container = ref<HTMLElement | null>(null);

// Add custom attributes to buttons after rendering
onMounted(() => {
  addZoneAttributes();
});

// Re-apply attributes when options change
watch(() => props.options, () => {
  setTimeout(addZoneAttributes, 0);
});

function addZoneAttributes() {
  if (!container.value) return;
  
  const buttons = container.value.querySelectorAll('button');
  buttons.forEach((button, index) => {
    if (index < props.options.length) {
      button.setAttribute('option-zone', props.options[index]);
    }
  });
}
</script>

<style lang="scss" scoped>
.zone-selector {
  width: 100%;
  

}

/* Define styles for each zone */
:deep(button[aria-pressed="true"]) {
  &[option-zone="Subject"] .p-togglebutton-content {
    background: linear-gradient(135deg, #C4B3FF 0%, #A38BFE 50%, #65F0D5 100%);
  }
  
  &[option-zone="Attributes"] .p-togglebutton-content {
    background: linear-gradient(135deg, #FFB5EC 0%, #FF8AE2 50%, #FFC46B 100%);
  }
  
  &[option-zone="Activity"] .p-togglebutton-content {
    background: linear-gradient(135deg, #B9FFFA 0%, #84FFF5 50%, #4C6EF5 100%);
  }
  
  &[option-zone="Aesthetics"] .p-togglebutton-content {
    background: linear-gradient(135deg, #DBFFE6 0%, #C2FFD8 50%, #465EFB 100%);
  }
  
  &[option-zone="Era"] .p-togglebutton-content {
    background: linear-gradient(135deg, #FFE57F 0%, #F9D423 50%, #FF4E50 100%);
  }
  
  &[option-zone="Abstract"] .p-togglebutton-content {
    background: linear-gradient(135deg, #9EAAFF 0%, #667EEA 50%, #764BA2 100%);
  }
  
  &[option-zone="Style"] .p-togglebutton-content {
    background: linear-gradient(135deg, #FFE6A0 0%, #F6D365 50%, #FDA085 100%);
  }
  

}

:deep(button[aria-pressed="true"]) {
    .zone-button-content {
        color: #fff;
    }
}

/* Add keyframes for the pulse animation */
@keyframes pulse {
  0% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 0.5;
    transform: scale(1.05);
  }
  100% {
    opacity: 0.3;
    transform: scale(1);
  }
}
</style>

================
File: composables/useForceSimulation.ts
================
import * as d3 from 'd3';
import type { GraphNode, GraphLink } from '~/types/graph';
import type { SimulationNodeDatum } from 'd3';

export function useForceSimulation() {
  /**
   * Creates and configures a D3 force simulation
   */
  const createSimulation = (
    nodes: GraphNode[],
    links: GraphLink[],
    width: number,
    height: number
  ) => {
    const simulation = d3.forceSimulation<GraphNode>(nodes)
      .force('link', d3.forceLink<GraphNode, GraphLink>(links)
        .id(d => d.id)
        .distance(link => {
          const target = link.target as GraphNode;
          const source = link.source as GraphNode;
          // Increase distance when target is selected
          if (target.selected) return 150;
          // Keep parent-child relationships closer
          if (target.parentId === source.id) return 50;
          return 140;
        })
        .strength(link => {
          const target = link.target as GraphNode;
          const source = link.source as GraphNode;
          // Weaken link when target is selected
          if (target.selected) return 0.05;
          // Stronger force for parent-child relationships
          if (target.parentId === source.id) return 0.1;
          return 0.15;
        }))
      .force('charge', d3.forceManyBody()
        .strength((d) => ((d as GraphNode).selected ? -100 : -20))) // Stronger repulsion for selected nodes
      .force('center', d3.forceCenter(width / 2, height / 2).strength(0.00))
      .force('collision', d3.forceCollide()
        .radius((d) => ((d as GraphNode).selected ? (d as GraphNode).size : (d as GraphNode).size / 2) + 20)) // Larger collision radius for selected nodes
      .velocityDecay(0.8);
      
    return simulation;
  };
  
  /**
   * Updates the simulation parameters when nodes or links change
   */
  const updateSimulation = (
    simulation: d3.Simulation<GraphNode, GraphLink>,
    nodes: GraphNode[],
    links: GraphLink[],
    width: number,
    height: number
  ) => {
    simulation.stop();

    const selectedParent = nodes.find(n => n.selected && !n.parentId);
    const parentX = selectedParent ? (selectedParent.x || width / 2) : width / 2;
    const parentY = selectedParent ? (selectedParent.y || height / 2) : height / 2;

    // Update node positions and fix selected nodes
    nodes.forEach(node => {
      if (node.selected && !node.parentId) {
        node.fx = node.x || parentX;
        node.fy = node.y || parentY;
      } else if (node.parentId) {
        const parent = nodes.find(n => n.id === node.parentId);
        if (parent && (!node.x || !node.y)) {
          node.x = parent.x || parentX;
          node.y = parent.y || parentY;
          node.vx = 0;
          node.vy = 0;
        }
      } else {
        node.fx = null;
        node.fy = null;
      }
    });

    // Update simulation nodes
    simulation.nodes(nodes);
    
    // Update link force
    const linkForceTyped = simulation.force<d3.ForceLink<GraphNode, GraphLink>>('link');
    if (linkForceTyped) {
      linkForceTyped.links(links);
      linkForceTyped
        .distance(link => {
          const target = link.target as GraphNode;
          const source = link.source as GraphNode;
          if (target.selected) return 150;
          if (target.parentId === source.id) return 50;
          return 100;
        })
        .strength(link => {
          const target = link.target as GraphNode;
          const source = link.source as GraphNode;
          if (target.selected) return 0.05;
          if (target.parentId === source.id) return 0.3;
          return 0.15;
        });
    }

    // Update charge force
    const chargeForce = simulation.force('charge') as d3.ForceManyBody<GraphNode>;
    if (chargeForce) {
      chargeForce.strength((d: SimulationNodeDatum) => ((d as GraphNode).selected ? -100 : -20));
    }

    // Update collision force
    const collisionForce = simulation.force('collision') as d3.ForceCollide<GraphNode>;
    if (collisionForce) {
      collisionForce.radius((d: SimulationNodeDatum) => ((d as GraphNode).selected ? (d as GraphNode).size : (d as GraphNode).size / 2) + 20);
    }

    // Restart simulation
    simulation.alpha(0.3).restart();
    
    return simulation;
  };
  
  /**
   * Creates a drag behavior for nodes
   */
  const createDragBehavior = (simulation: d3.Simulation<GraphNode, GraphLink>) => {
    return d3.drag<any, GraphNode>()
      .on('start', (event) => {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      })
      .on('drag', (event) => {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      })
      .on('end', (event) => {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      });
  };
  
  return {
    createSimulation,
    updateSimulation,
    createDragBehavior
  };
}

================
File: composables/useLinkStyling.ts
================
import { type Selection } from 'd3';
import type { GraphLink, GraphNode } from '~/types/graph';

export function useLinkStyling() {
  /**
   * Creates a link gradient definition in the SVG
   */
  const createLinkGradient = (
    svg: Selection<SVGSVGElement, unknown, null, undefined>,
    id: string = 'link-gradient'
  ) => {
    // Create default gradient for links
    const linkGradient = svg.select('defs')
      .append('linearGradient')
      .attr('id', id)
      .attr('gradientUnits', 'userSpaceOnUse')
      .attr('x1', '0%')
      .attr('y1', '0%')
      .attr('x2', '100%')
      .attr('y2', '0%');
    
    // Add stops to the gradient - subtle fade
    linkGradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', '#aaa')
      .attr('stop-opacity', '0');
      
    linkGradient.append('stop')
      .attr('offset', '20%')
      .attr('stop-color', '#aaa')
      .attr('stop-opacity', '0.5');
      
    linkGradient.append('stop')
      .attr('offset', '80%')
      .attr('stop-color', '#aaa')
      .attr('stop-opacity', '0.5');
      
    linkGradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', '#aaa')
      .attr('stop-opacity', '0');
      
    return linkGradient;
  };

  /**
   * Creates a unique gradient for a specific link
   */
  const createUniqueGradient = (
    svg: Selection<SVGSVGElement, unknown, null, undefined>,
    source: GraphNode,
    target: GraphNode
  ): string => {
    const gradientId = `link-gradient-${source.id}-${target.id}`;
    
    // Check if this gradient already exists
    if (svg.select(`#${gradientId}`).empty()) {
      // Create a new gradient for this link
      createLinkGradient(svg, gradientId);
      
      // Update the gradient orientation
      updateGradientPositions(svg, source, target);
    }
    
    return gradientId;
  };
  
  /**
   * Updates gradient positions based on node positions
   */
  const updateGradientPositions = (
    svg: Selection<SVGSVGElement, unknown, null, undefined>,
    source: GraphNode,
    target: GraphNode
  ) => {
    const gradientId = `link-gradient-${source.id}-${target.id}`;
    svg.select(`#${gradientId}`)
      .attr('x1', source.x || 0)
      .attr('y1', source.y || 0)
      .attr('x2', target.x || 0)
      .attr('y2', target.y || 0);
  };
  
  /**
   * Apply styling to a link
   */
  const applyLinkStyle = (
    selection: Selection<any, GraphLink, any, any>
  ) => {
    selection
      .attr('stroke-opacity', 0.5)
      .attr('stroke-width', d => Math.max(1, Math.sqrt(d.value) * 0.7))
      .attr('stroke-linecap', 'round');
  };

  return {
    createLinkGradient,
    createUniqueGradient,
    updateGradientPositions,
    applyLinkStyle
  };
}

================
File: composables/useNodeStyling.ts
================
import { type Selection } from 'd3';
import type { GraphNode } from '~/types/graph';
import * as d3 from 'd3';

export function useNodeStyling() {
  /**
   * Maps zone names to their gradient colors
   */
  const zoneGradients = {
    'Subject': { 
      light: '#C4B3FF',  // Lighter lavender
      main: '#A38BFE',   // Main lavender
      dark: '#65F0D5'    // Mint accent
    },
    'Attributes': { 
      light: '#FFB5EC',  // Lighter pink
      main: '#FF8AE2',   // Main pink
      dark: '#FFC46B'    // Gold accent
    },
    'Activity': { 
      light: '#B9FFFA',  // Lighter cyan
      main: '#84FFF5',   // Main cyan
      dark: '#4C6EF5'    // Indigo accent
    },
    'Composition': { 
      light: '#FFE6A0',  // Lighter yellow
      main: '#F6D365',   // Main yellow
      dark: '#FDA085'    // Peach accent
    },
    'Aesthetics': { 
      light: '#DBFFE6',  // Lighter mint
      main: '#C2FFD8',   // Main mint
      dark: '#465EFB'    // Blue accent
    },
    'Era': { 
      light: '#FFE57F',  // Lighter gold
      main: '#F9D423',   // Main gold
      dark: '#FF4E50'    // Red accent
    },
    'Abstract': { 
      light: '#9EAAFF',  // Lighter indigo
      main: '#667EEA',   // Main indigo
      dark: '#764BA2'    // Purple accent
    }
  };

  // Default gradient for fallback
  const defaultGradient = { 
    light: '#9B9DFF',
    main: '#6366f1', 
    dark: '#8B5CF6' 
  };
  
  /**
   * Creates node gradient definitions in the SVG
   */
  const createNodeGradients = (svg: Selection<SVGSVGElement, unknown, null, undefined>) => {
    // First check if we already have defs
    if (svg.select('defs').empty()) {
      svg.append('defs');
    }
    
    const defs = svg.select('defs');
    
    // Create gradients for each zone
    Object.entries(zoneGradients).forEach(([zone, colors]) => {
      const gradientId = `node-gradient-${zone.toLowerCase()}`;
      
      // Only create if it doesn't exist yet
      if (defs.select(`#${gradientId}`).empty()) {
        // Create a radial gradient for sphere-like effect
        const gradient = defs.append('radialGradient')
          .attr('id', gradientId)
          .attr('cx', '30%')      // Move highlight more to the top-left
          .attr('cy', '30%')
          .attr('r', '80%')       // Cover more of the circle
          .attr('fx', '7%')      // Focus highlight in top-left corner
          .attr('fy', '7%');
          
        // Start with a lighter version of the main color at center
        gradient.append('stop')
          .attr('offset', '0%')
          .attr('stop-color', colors.light)  // Lighter shade
          .attr('stop-opacity', '1');
          
        // Transition to main color
        gradient.append('stop')
          .attr('offset', '30%')
          .attr('stop-color', colors.main)   // Main color
          .attr('stop-opacity', '1');
          
        // Transition to darker end color
        gradient.append('stop')
          .attr('offset', '100%')
          .attr('stop-color', colors.dark)   // Darker accent color
          .attr('stop-opacity', '0.9');
        
        // Add glow filter
        if (defs.select(`#glow-${zone.toLowerCase()}`).empty()) {
          const filter = defs.append('filter')
            .attr('id', `glow-${zone.toLowerCase()}`)
            .attr('x', '-30%')
            .attr('y', '-30%')
            .attr('width', '160%')
            .attr('height', '160%');
            
          // Add subtle blur effect
          filter.append('feGaussianBlur')
            .attr('stdDeviation', '1.5')
            .attr('result', 'blur');
            
          // Combine original with blur
          filter.append('feComposite')
            .attr('in', 'SourceGraphic')
            .attr('in2', 'blur')
            .attr('operator', 'over');
        }
      }
    });
    
    // Create default gradient
    if (defs.select('#node-gradient-default').empty()) {
      const gradient = defs.append('radialGradient')
        .attr('id', 'node-gradient-default')
        .attr('cx', '30%')
        .attr('cy', '30%')
        .attr('r', '80%')
        .attr('fx', '15%')
        .attr('fy', '15%');
        
      gradient.append('stop')
        .attr('offset', '0%')
        .attr('stop-color', defaultGradient.light)
        .attr('stop-opacity', '1');
        
      gradient.append('stop')
        .attr('offset', '30%')
        .attr('stop-color', defaultGradient.main)
        .attr('stop-opacity', '1');
        
      gradient.append('stop')
        .attr('offset', '100%')
        .attr('stop-color', defaultGradient.dark)
        .attr('stop-opacity', '0.9');
        
      // Add default glow
      if (defs.select('#glow-default').empty()) {
        const filter = defs.append('filter')
          .attr('id', 'glow-default')
          .attr('x', '-30%')
          .attr('y', '-30%')
          .attr('width', '160%')
          .attr('height', '160%');
          
        filter.append('feGaussianBlur')
          .attr('stdDeviation', '1.5')
          .attr('result', 'blur');
          
        filter.append('feComposite')
          .attr('in', 'SourceGraphic')
          .attr('in2', 'blur')
          .attr('operator', 'over');
      }
    }
  };
  
  /**
   * Gets the gradient URL for a node based on its zone
   */
  const getNodeGradient = (node: GraphNode): string => {
    if (!node.selected) {
      return 'rgba(255, 255, 255, 0.2)';
    }
    
    const zone = node.zone || 'default';
    const normalizedZone = Object.keys(zoneGradients).find(
      z => z.toLowerCase() === zone.toLowerCase()
    ) || 'default';
    
    return `url(#node-gradient-${normalizedZone.toLowerCase()})`;
  };
  
  /**
   * Gets the glow filter URL for a node based on its zone
   */
  const getNodeGlowFilter = (node: GraphNode): string | null => {
    if (!node.selected) {
      return null;
    }
    
    const zone = node.zone || 'default';
    const normalizedZone = Object.keys(zoneGradients).find(
      z => z.toLowerCase() === zone.toLowerCase()
    ) || 'default';
    
    return `url(#glow-${normalizedZone.toLowerCase()})`;
  };

  /**
   * Applies styling to a graph node
   */
  const applyNodeStyle = (
    selection: Selection<any, GraphNode, any, any>,
    isHover = false,
    svg?: Selection<SVGSVGElement, unknown, null, undefined> | null
  ) => {
    // Create gradients if we have the SVG reference
    if (svg) {
      createNodeGradients(svg);
    }
    
    // Apply circle styling
    selection.select('.node-circle')
      .attr('fill', d => getNodeGradient(d))
      .attr('filter', d => isHover && d.selected ? getNodeGlowFilter(d) : null)
      .attr('stroke', d => {
        if (d.selected) return '#fff';
        return isHover ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.5)';
      })
      .attr('stroke-width', d => d.selected ? 1.5 : 1)
      .attr('r', d => d.size / 2);
    
    // Update text content and styling
    selection.selectAll('.node-text').remove(); // Remove existing text
    
    // Function to format text into multiple lines if needed
    const formatNodeText = (text: string): string[] => {
      const words = text.split(' ');
      
      // If single word or empty, return as is
      if (words.length <= 1) {
        return [text];
      }
      
      // For two words, split into two lines
      if (words.length === 2) {
        return words;
      }
      
      // For three words, put first word on first line, remaining on second
      if (words.length === 3) {
        return [
          words[0],
          `${words[1]} ${words[2]}`
        ];
      }
      
      // For more than three words, try to balance lines
      // Prioritize putting fewer words on the first line
      const firstLineCount = Math.floor(words.length / 2);
      return [
        words.slice(0, firstLineCount).join(' '),
        words.slice(firstLineCount).join(' ')
      ];
    };
    
    // Add text labels directly to the node (not in a group)
    selection.each(function(d) {
      const node = d3.select(this);
      const textLines = formatNodeText(d.text);
      
      // Remove any existing node-text
      node.selectAll('.node-text').remove();
      
      // For single-line text, use the standard approach
      if (textLines.length === 1) {
        node.append('text')
          .attr('class', 'node-text')
          .attr('x', 0) // Center horizontally
          .attr('y', d.size / 2 + 6) // Position below the circle
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'hanging') // Align from the top of the text
          .attr('font-size', '10px')
          .attr('fill', 'rgba(0, 0, 0, 0.8)')
          .attr('font-weight', d.selected ? '600' : '500')
          .attr('text-shadow', '0 0 4px rgba(255, 255, 255, 0.9)')
          .text(d.text);
        return;
      }
      
      // For multi-line text, create separate text elements
      textLines.forEach((line, i) => {
        const yPos = d.size / 2 + 6 + (i * 12); // Start closer to node and add line height
        
        node.append('text')
          .attr('class', 'node-text')
          .attr('x', 0) // Center horizontally
          .attr('y', yPos) // Position based on line number
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'hanging') // Align from the top of the text
          .attr('font-size', '10px')
          .attr('fill', 'rgba(0, 0, 0, 0.8)')
          .attr('font-weight', d.selected ? '600' : '500')
          .attr('text-shadow', '0 0 4px rgba(255, 255, 255, 0.9)')
          .text(line);
      });
    });
    
    // Selected nodes should be brought to front
    if (selection.data()[0]?.selected) {
      selection.raise();
    }
  };

  /**
   * Gets the image path for a subject node
   */
  const getSubjectImagePath = (text: string): string => {
    // Map the node text to the correct filename
    const nodeTextToFilename: Record<string, string> = {
      'Humans': 'humans',
      'Animals': 'animals',
      'Mythical Creatures': 'mythical-creatures',
      'Plants': 'plants',
      'Objects': 'objects',
      'Abstract Concepts': 'abstract-concepts',
      'Structures': 'structures',
      'Landscapes': 'landscapes'
    };
    
    const filename = nodeTextToFilename[text] || text.toLowerCase().replace(/\s+/g, '-');
    // Use dynamic imports of assets instead of hard-coded paths
    return new URL(`/assets/pics/subject/${filename}.png`, import.meta.url).href;
  };

  return {
    applyNodeStyle,
    getSubjectImagePath,
    createNodeGradients
  };
}

================
File: composables/useZoom.ts
================
import { ref } from 'vue';
import * as d3 from 'd3';

export function useZoom() {
  const zoomBehavior = ref<d3.ZoomBehavior<SVGSVGElement, unknown> | null>(null);
  const currentTransform = ref<d3.ZoomTransform>(d3.zoomIdentity);

  function initializeZoom(
    svg: d3.Selection<SVGSVGElement, unknown, null, undefined>, 
    g: d3.Selection<SVGGElement, unknown, null, undefined>,
    initialScale: number = 1.0
  ) {
    // Initialize zoom behavior
    zoomBehavior.value = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.2, 4]) // Set min/max zoom scale
      .on('zoom', (event) => {
        currentTransform.value = event.transform;
        g.attr('transform', event.transform.toString());
      });

    // Apply zoom behavior to SVG with initial scale
    svg.call(zoomBehavior.value as any);
    
    // Set initial zoom level
    const initialTransform = d3.zoomIdentity.scale(initialScale);
    svg.call(zoomBehavior.value.transform as any, initialTransform);
  }

  function centerOnNode(
    svg: d3.Selection<SVGSVGElement, unknown, null, undefined>,
    node: { x?: number; y?: number },
    width: number,
    height: number
  ) {
    if (!zoomBehavior.value || !svg.node() || !node.x || !node.y) return;

    // Get current transform state
    const currentTransform = d3.zoomTransform(svg.node()!);
    const scale = currentTransform.k;

    // Calculate center point
    const centerX = width / 2;
    const centerY = height / 2;

    // Calculate the new transform
    const newTransform = d3.zoomIdentity
      .translate(centerX - node.x * scale, centerY - node.y * scale)
      .scale(scale);

    // Apply smooth transition
    svg.transition()
      .duration(750)
      .call(zoomBehavior.value.transform as any, newTransform);
  }

  function zoomIn(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>) {
    if (!zoomBehavior.value) return;
    svg.transition()
      .duration(300)
      .call(zoomBehavior.value.scaleBy as any, 1.5);
  }

  function zoomOut(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>) {
    if (!zoomBehavior.value) return;
    svg.transition()
      .duration(300)
      .call(zoomBehavior.value.scaleBy as any, 0.75);
  }

  function resetZoom(svg: d3.Selection<SVGSVGElement, unknown, null, undefined>) {
    if (!zoomBehavior.value) return;
    svg.transition()
      .duration(300)
      .call(zoomBehavior.value.transform as any, d3.zoomIdentity);
  }

  return {
    zoomBehavior,
    currentTransform,
    initializeZoom,
    centerOnNode,
    zoomIn,
    zoomOut,
    resetZoom
  };
}

================
File: pages/index.vue
================
<template>
    <div class="mx-auto max-w-[96vw]">
      <TagCloud />
    </div>
  </template>
  
  <script setup lang="ts">
  import TagCloud from '~/components/TagCloud.vue'
  </script>

================
File: public/robots.txt
================


================
File: server/tsconfig.json
================
{
  "extends": "../.nuxt/tsconfig.server.json"
}

================
File: services/graphLayoutService.ts
================
import type { Tag } from '~/types/tag';

export function distributeChildNodes(parentTag: Tag, radius: number): void {
  const children = parentTag.children || [];
  if (children.length === 0) return;
  
  const angleIncrement = (2 * Math.PI) / children.length;
  children.forEach((child, i) => {
    const angle = i * angleIncrement;
    const px = parentTag.x ?? 300;
    const py = parentTag.y ?? 200;
    child.x = px + radius * Math.cos(angle);
    child.y = py + radius * Math.sin(angle);
  });
}

export function expandChildAwayFromParent(child: Tag, parent: Tag): void {
  if (!parent) return;
  
  const dx = (child.x ?? 0) - (parent.x ?? 0);
  const dy = (child.y ?? 0) - (parent.y ?? 0);
  const distance = Math.sqrt(dx * dx + dy * dy);
  const newDistance = distance * 3; // Increase by factor of 3
  const ux = dx / distance;
  const uy = dy / distance;
  
  child.x = (parent.x ?? 0) + newDistance * ux;
  child.y = (parent.y ?? 0) + newDistance * uy;
}

interface GraphData {
  nodes: Tag[];
  links: Array<{ source: string; target: string; value: number }>;
}

export function computeGraphData(tags: Tag[], focusedZone: string): GraphData {
  // Get visible nodes
  const zoneTags = tags.filter(t => t.zone === focusedZone);
  const topLevel = zoneTags.filter(t => !t.parentId);
  
  if (!topLevel.some(t => t.selected)) {
    return {
      nodes: topLevel,
      links: []
    };
  }

  // Build visible nodes tree
  let activeTop = topLevel.filter(t => t.selected);
  let visible: Tag[] = [...activeTop];
  let currentLevel = activeTop;

  while (true) {
    const nextLevel = currentLevel.flatMap(node => 
      (node.children && !node.isLoading ? node.children : [])
    );
    if (nextLevel.length === 0) break;
    visible.push(...nextLevel);
    const selectedNext = nextLevel.filter(n => n.selected);
    if (selectedNext.length === 0) break;
    currentLevel = selectedNext;
  }

  // Build links between visible nodes
  const links = visible.reduce((acc: Array<{ source: string; target: string; value: number }>, node) => {
    if (node.children) {
      node.children.forEach(child => {
        if (visible.some(n => n.id === child.id)) {
          acc.push({ source: node.id, target: child.id, value: 1 });
        }
      });
    }
    return acc;
  }, []);

  return {
    nodes: visible,
    links
  };
}

================
File: services/tagGenerationService.ts
================
import { GoogleGenerativeAI } from '@google/generative-ai';
import type { Tag } from '~/types/tag';

export async function generateRelatedTags(
  parentTag: Tag,
  existingTags: Tag[],
  apiKey: string
): Promise<Tag[]> {
  const existingTexts = existingTags
    .filter(t => t.zone === parentTag.zone)
    .map(t => t.text.toLowerCase());

  const genAI = new GoogleGenerativeAI(apiKey);
  const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash-8b' });

  const prompt = `You are helping users find relevant tags for their image generation. 
When user selects "${parentTag.text}" as their main subject in the "${parentTag.zone}" zone, suggest 6 additional descriptive tags.

Context about the application's zone structure:
- Our application has several zones: Subject, Mood, Setting, Activity, Aesthetic, etc.
- Each zone contains different types of concepts.
- The user is currently in the "${parentTag.zone}" zone, so all suggestions must be appropriate for this specific zone.
- Tags from the ${parentTag.zone} zone should only describe ${parentTag.zone.toLowerCase()} elements, not elements from other zones.

Examples by zone:
- Subject zone: objects, beings, or things (e.g., "Mountain", "Tiger", "Robot")
- Mood zone: emotional qualities (e.g., "Serene", "Mysterious", "Joyful")
- Setting zone: locations or environments (e.g., "Forest", "Urban", "Underwater")
- Aesthetic zone: artistic styles (e.g., "Minimalist", "Surreal", "Vintage")

Requirements:
- Each tag should be 1-2 words
- Always start with a capital letter
- Avoid duplicating these existing tags: ${existingTexts.join(', ')}
- Think about what users might want to achieve when they selected "${parentTag.text}" in the "${parentTag.zone}" zone
- Include both common and creative but relevant associations
- Focus on visual and artistic aspects that fit the "${parentTag.zone}" zone
- Suggest tags that would help create interesting image variations
- Keep tags concrete and imagery-focused
- IMPORTANT: Only suggest tags that belong in the "${parentTag.zone}" zone. Do not mix concepts from different zones.

Return only a JSON array of strings, no explanation.
Example format: ["Mountain Peak", "Dense Forest", "Morning Mist"]`;

  try {
    const response = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: prompt }] }],
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 200
      }
    });

    const rawText = response.response.text();
    const cleanedText = rawText.replace(/```json\n|\n```/g, '').trim();
    const newTagsText = JSON.parse(cleanedText) as string[];

    return newTagsText.map((text: string, index: number): Tag => ({
      id: `${parentTag.id}-dyn-${index}`,
      text,
      size: 40,
      selected: false,
      zone: parentTag.zone,
      alias: text.toLowerCase().replace(/\s+/g, '-'),
      parentId: parentTag.id,
      x: parentTag.x,
      y: parentTag.y,
      isLoading: false,
      children: [],
      depth: (parentTag.depth ?? 0) + 1
    }));
  } catch (error) {
    console.error('Error fetching dynamic tags:', error);
    throw error;
  }
}

================
File: services/tagProcessingService.ts
================
import type { Tag } from '~/types/tag';
import { mockTags } from '~/store/mockTags';

export function getAvailableZones(): string[] {
  return Object.keys(mockTags).length > 0 
    ? Object.keys(mockTags)
    : ['Subject', 'Style', 'Medium', 'Mood'];
}

export function processTag(
  tagData: string | Tag,
  zone: string,
  existingTags: Tag[],
  parentId?: string,
  level: number = 0
): Tag {
  const isString = typeof tagData === 'string';
  const text = isString ? tagData : tagData.text;
  const id = parentId ? `${parentId}-${existingTags.length}` : `${zone}-${existingTags.length}`;
  
  const tag: Tag = {
    id,
    text,
    size: 40,
    selected: false,
    zone,
    alias: (isString ? text.toLowerCase().replace(/\s+/g, '-') : tagData.alias) || '',
    parentId,
    x: level === 0 ? 300 : undefined,
    y: level === 0 ? 200 : undefined,
    isLoading: false,
    children: [],
    depth: level
  };

  // Process children if they exist
  if (!isString && tagData.children) {
    // Process both predefined and dynamic children
    tag.children = tagData.children.map(child => {
      const childTag = processTag(child, zone, existingTags, tag.id, level + 1);
      existingTags.push(childTag); // Add child to existingTags
      return childTag;
    });
  }

  return tag;
}

export function initializeTags(): Tag[] {
  const tags: Tag[] = [];
  
  // If mockTags is empty or undefined, provide default tags
  const defaultTags: Record<string, (string | Tag)[]> = {
    Subject: ['Portrait', 'Landscape', 'Abstract'],
    Style: ['Realistic', 'Impressionist', 'Minimalist'],
    Medium: ['Digital', 'Oil Paint', 'Watercolor'],
    Mood: ['Peaceful', 'Energetic', 'Mysterious']
  };

  const tagsToProcess = Object.keys(mockTags).length > 0 ? mockTags : defaultTags;
  
  Object.entries(tagsToProcess).forEach(([zone, zoneTags]) => {
    zoneTags.forEach((tagData: string | Tag) => {
      const tag = processTag(tagData, zone, tags);
      if (!tag.parentId) { // Only push top-level tags directly
        tags.push(tag);
      }
    });
  });

  return tags;
}

export function findTagById(id: string, tagList: Tag[]): Tag | undefined {
  for (const tag of tagList) {
    if (tag.id === id) return tag;
    if (tag.children) {
      const found = findTagById(id, tag.children);
      if (found) return found;
    }
  }
  return undefined;
}

================
File: services/tagSelectionService.ts
================
import type { Tag } from '~/types/tag';
import { findTagById } from './tagProcessingService';
import { generateRelatedTags } from './tagGenerationService';
import { distributeChildNodes, expandChildAwayFromParent } from './graphLayoutService';

export function removeDynamicChildren(tag: Tag, allTags: Tag[]): Tag[] {
  if (!tag.children) return allTags;

  // Identify dynamic children
  const dynamicIds = tag.children
    .filter(child => child.id.includes('-dyn-'))
    .map(child => child.id);

  // Remove from parent's children
  tag.children = tag.children.filter(child => !child.id.includes('-dyn-'));

  // Remove from global tags array
  return allTags.filter(t => !dynamicIds.includes(t.id));
}

export function unselectChildren(tag: Tag): void {
  if (tag.children) {
    tag.children.forEach(child => {
      child.selected = false;
      unselectChildren(child);
    });
  }
}

export function unselectTopLevelSiblings(tag: Tag, allTags: Tag[]): void {
  if (!tag.parentId) {
    allTags
      .filter(t => t.zone === tag.zone && !t.parentId && t.id !== tag.id)
      .forEach(t => {
        if (t.selected) {
          allTags = removeDynamicChildren(t, allTags);
        }
        t.selected = false;
        unselectChildren(t);
      });
  }
}

export async function toggleTag(
  id: string,
  allTags: Tag[],
  apiKey: string
): Promise<{ updatedTags: Tag[]; selectedTag: Tag }> {
  const tag = findTagById(id, allTags);
  if (!tag) {
    throw new Error(`Tag ${id} not found`);
  }

  const wasSelected = tag.selected;
  let updatedTags = [...allTags];

  if (!wasSelected) {
    unselectTopLevelSiblings(tag, updatedTags);
    tag.selected = true;

    if (tag.parentId) {
      const parent = findTagById(tag.parentId, updatedTags);
      if (parent) {
        expandChildAwayFromParent(tag, parent);
      }
    }

    try {
      tag.isLoading = true;
      const newTags = await generateRelatedTags(tag, updatedTags, apiKey);
      tag.children = [...(tag.children || []), ...newTags];
      updatedTags = [...updatedTags, ...newTags];
      // Distribute children in a circle after adding new ones
      distributeChildNodes(tag, 80);
    } finally {
      tag.isLoading = false;
    }
  } else {
    updatedTags = removeDynamicChildren(tag, updatedTags);
    unselectChildren(tag);
    tag.selected = false;
  }

  return { updatedTags, selectedTag: tag };
}

================
File: store/mockTags.ts
================
export const mockTags = {
  Subject: [
    {
      text: 'Humans',
        alias: 'humans',
        children: [
          'Adult Male',
          'Adult Female',
          'Child',
          'Elderly',
          'Group of People',
          'Portrait',
          'Silhouette',
          'Diverse Cultures'
        ]
   
================
File: store/tagStore.ts
================
// stores/tagStore.ts
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { useRuntimeConfig } from '#app';
import type { Tag } from '~/types/tag';
import { initializeTags, getAvailableZones } from '~/services/tagProcessingService';
import { toggleTag } from '~/services/tagSelectionService';
import { computeGraphData } from '~/services/graphLayoutService';

export const useTagStore = defineStore('tags', () => {
  const tags = ref<Tag[]>([]);
  const zones = ref<string[]>(getAvailableZones());
  const focusedZone = ref<string>(zones.value[0] || 'Subject');

  // Initialize tags on store creation
  tags.value = initializeTags();

  function setFocusedZone(zone: string) {
    console.log(`Setting focused zone to ${zone}`);
    focusedZone.value = zone;
  }

  async function handleTagToggle(id: string) {
    const config = useRuntimeConfig();
    const apiKey = config.public.GEMINI_API_KEY;
    
    if (!apiKey) {
      throw new Error('GEMINI_API_KEY is not defined');
    }

    const { updatedTags, selectedTag } = await toggleTag(id, tags.value, apiKey);
    tags.value = updatedTags;
    console.log(`Toggled tag ${id} to selected: ${selectedTag.selected}`);
  }

  // Computed properties for graph visualization
  const graphNodes = computed(() => computeGraphData(tags.value, focusedZone.value).nodes);
  const graphLinks = computed(() => computeGraphData(tags.value, focusedZone.value).links);

  return {
    tags,
    zones,
    focusedZone,
    setFocusedZone,
    toggleTag: handleTagToggle,
    graphNodes,
    graphLinks
  };
});

================
File: types/graph.ts
================
import type { SimulationNodeDatum, SimulationLinkDatum } from 'd3';

/**
 * Represents a node in the force-directed graph
 */
export interface GraphNode extends SimulationNodeDatum {
  id: string;
  text: string;
  size: number;
  selected: boolean;
  zone: string;
  alias: string;
  children?: GraphNode[];
  parentId?: string;
  x?: number;
  y?: number;
  isLoading?: boolean;
}

/**
 * Represents a link between nodes in the force-directed graph
 */
export interface GraphLink extends SimulationLinkDatum<GraphNode> {
  value: number;
}

================
File: types/tag.ts
================
export interface Tag {
  id: string;
  text: string;
  size: number;
  selected: boolean;
  zone: string;
  alias: string;
  children?: Tag[];
  parentId?: string;
  x?: number;
  y?: number;
  isLoading?: boolean;
  depth?: number;
}

================
File: .eslintrc.js
================
module.exports = {
  root: true,
  env: {
    browser: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:vue/vue3-recommended',
    'prettier',
  ],
  plugins: ['@typescript-eslint', 'prettier'],
  parser: 'vue-eslint-parser',
  parserOptions: {
    parser: '@typescript-eslint/parser',
    sourceType: 'module',
    ecmaVersion: 2020,
  },
  rules: {
    'prettier/prettier': 'error',
    // Add any other custom rules here
  },
}

================
File: .gitignore
================
# Nuxt dev/build outputs
.output
.data
.nuxt
.nitro
.cache
dist

# Node dependencies
node_modules

# Logs
logs
*.log

# Misc
.DS_Store
.fleet
.idea

# Local env files
.env
.env.*
!.env.example

================
File: .prettierrc
================
{
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "printWidth": 100
}

================
File: app.vue
================
<template>
  <div class="app-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Logo at the top -->
      <div class="logo-container">
        <img src="/assets/dreamseed-logo.png" alt="DreamSeed" class="logo">
      </div>
      
      <!-- Navigation items -->
      <nav class="nav-menu">
        <a href="#" class="nav-item active">
          <i class="pi pi-home"></i>
          <span>Home</span>
        </a>
        <a href="#" class="nav-item">
          <i class="pi pi-plus"></i>
          <span>Create</span>
        </a>
        <a href="#" class="nav-item">
          <i class="pi pi-images"></i>
          <span>Library</span>
        </a>
        <a href="#" class="nav-item">
          <i class="pi pi-compass"></i>
          <span>Explore</span>
        </a>
        <a href="#" class="nav-item">
          <i class="pi pi-search"></i>
          <span>Search</span>
        </a>
        <a href="#" class="nav-item">
          <i class="pi pi-bell"></i>
          <span>Notifications</span>
        </a>
      </nav>
      
      <!-- User section at bottom -->
      <div class="user-section">
        <div class="user-profile">
          <div class="user-avatar">
            <i class="pi pi-user"></i>
          </div>
          <span class="user-name">User</span>
        </div>
      </div>
    </div>
    
    <!-- Main content -->
    <div class="main-content">
      <NuxtPage />
    </div>
  </div>
</template>

<style lang="scss">
.app-container {
  display: flex;
  width: 100%;
  min-height: 100vh;
}

.sidebar {
  width: 220px;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  flex-direction: column;
  padding: 20px 0;
  backdrop-filter: blur(10px);
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
  flex-shrink: 0;
  position: relative;
  z-index: 10;
}

.logo-container {
  padding: 10px 20px 25px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  margin-bottom: 15px;
  
  .logo {
    height: 40px;
    width: auto;
  }
}

.nav-menu {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  
  .nav-item {
    display: flex;
    align-items: center;
    padding: 12px 20px;
    color: rgba(255, 255, 255, 0.7);
    text-decoration: none;
    transition: all 0.2s ease;
    
    i {
      margin-right: 12px;
      font-size: 1.2rem;
    }
    
    &:hover, &.active {
      color: #fff;
      background-color: rgba(255, 255, 255, 0.1);
    }
    
    &.active {
      border-left: 3px solid #8EC5FC;
      padding-left: 17px;
    }
  }
}

.user-section {
  margin-top: auto;
  padding: 15px 20px;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
  
  .user-profile {
    display: flex;
    align-items: center;
    
    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: linear-gradient(135deg, #8EC5FC, #E0C3FC);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
      
      i {
        color: #fff;
        font-size: 0.9rem;
      }
    }
    
    .user-name {
      color: #fff;
      font-size: 0.9rem;
    }
  }
}

.main-content {
  flex: 1;
  padding: 20px;
  overflow-x: hidden;
  min-width: 0;
}
</style>

================
File: nuxt.config.ts
================
import Aura from '@primeuix/themes/aura';
import { definePreset } from '@primeuix/themes';


const MyPreset = definePreset(Aura, {
  semantic: {
      primary: {
          50: '{indigo.50}',
          100: '{indigo.100}',
          200: '{indigo.200}',
          300: '{indigo.300}',
          400: '{indigo.400}',
          500: '{indigo.500}',
          600: '{indigo.600}',
          700: '{indigo.700}',
          800: '{indigo.800}',
          900: '{indigo.900}',
          950: '{indigo.950}'
      }
  }
});


export default defineNuxtConfig({
  modules: [
    '@primevue/nuxt-module',
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt',
    '@nuxtjs/google-fonts', // Add the google fonts module
  ],
  googleFonts: { // Add google fonts configuration
    families: {
      Roboto: true // Specify Roboto font
    }
  },
  primevue: {
    options: {
        theme: {
            options: {
                darkModeSelector: '.my-app-dark',
            },
            preset: MyPreset
        },
    }
},

  css: [
    'primeicons/primeicons.css',       // Add PrimeIcons CSS
    '~/assets/scss/main.scss',         // Your main SCSS file
  ],

  runtimeConfig: {
    public: {
      GEMINI_API_KEY: process.env.GEMINI_API_KEY,
      FLUX_API_KEY: process.env.FLUX_API_KEY
    }
  },

  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "~/assets/scss/variables.scss";',
        },
      },
    },
  },

  typescript: {
    strict: true
  },

  compatibilityDate: '2024-10-07',

  tailwindcss: {
    configPath: './tailwind.config.js', // Reference to the separate config file
  },

  postcss: {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  },

})

================
File: package.json
================
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare",
    "lint": "eslint --ext .js,.ts,.vue --ignore-path .gitignore .",
    "lint:fix": "eslint --fix --ext .js,.ts,.vue --ignore-path .gitignore .",
    "format": "prettier --write \"**/*.{js,ts,vue,scss,html,md,json}\" --ignore-path .gitignore"
  },
  "dependencies": {
    "@google/generative-ai": "0.8.0",
    "@heroicons/vue": "^2.1.5",
    "@nuxtjs/tailwindcss": "^6.12.2",
    "@pinia/nuxt": "^0.5.5",
    "@primeuix/themes": "^1.0.0",
    "@primevue/forms": "^4.3.3",
    "d3": "^7.9.0",
    "d3-force": "^3.0.0",
    "gsap": "^3.12.5",
    "nuxt": "^3.13.0",
    "pinia": "^2.2.4",
    "primeicons": "^7.0.0",
    "primevue": "^4.3.3",
    "sass": "^1.79.4",
    "tailwindcss-primeui": "^0.6.1",
    "typescript": "^5.6.3",
    "vue": "latest",
    "vue-router": "latest"
  },
  "packageManager": "pnpm@9.12.3+sha512.cce0f9de9c5a7c95bef944169cc5dfe8741abfb145078c0d508b868056848a87c81e626246cb60967cbd7fd29a6c062ef73ff840d96b3c86c40ac92cf4a813ee",
  "devDependencies": {
    "@nuxtjs/google-fonts": "^3.2.0",
    "@primevue/nuxt-module": "^4.3.3",
    "@types/d3": "^7.4.3",
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "@typescript-eslint/parser": "^5.0.0",
    "autoprefixer": "^10.4.20",
    "eslint": "^6.8.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^4.0.0",
    "postcss": "^8.4.48",
    "prettier": "^2.5.1",
    "prettier-eslint": "^13.0.0",
    "tailwindcss": "^3.4.14"
  }
}



Overview
This is a Nuxt.js application with Vue.js and D3.js, designed to visualize and interact with a tag-based system for generating image prompts. Users can select tags organized by zones (e.g., Subject), with parent tags (e.g., Humans, Animals) and secondary tags (e.g., Adult Male, Mammals) displayed in a force-directed graph. The project aims to eventually support dynamic tags (fetched from a server) and hybrid tags (combinations of selected tags).

Core Components
TagCloud.vue: The main UI component, orchestrating zone switching and node interactions, interfacing with the store.
ForceGraph.vue: A reusable D3.js force-directed graph component, rendering nodes and links based on props, emitting events for interactions.
tagStore.ts: A Pinia store managing tags, zones, and graph data (nodes and links).

Project Structure
components/
  TagCloud.vue
  ForceGraph.vue
stores/
  tagStore.ts
types/
  (future: shared interfaces like Tag)
utils/
  (future: layout helpers if needed)

Core Functionalities
1. Zone-Based Tag System
Description: Tags are grouped into zones (e.g., Subject), each containing parent tags with optional secondary tags.
Implementation:
tagStore.ts holds zones (Subject), parent tags (Humans, Animals), and secondary tags (Adult Male, etc.).
TagCloud.vue displays the current zone via focusedZone and switches with buttons.
Behavior: Only one zone is active at a time, showing its parent tags initially; selecting a parent reveals its secondary tags.
2. Force-Directed Graph Visualization
Description: Displays tags as nodes and relationships as links in a dynamic graph.
Implementation:
ForceGraph.vue uses D3’s forceSimulation to position nodes (props.nodes) and links (props.links).
Nodes are <g> elements with <circle> (visual) and <text> (label); links are <line> elements.
Behavior: 
Parent nodes start centered (e.g., (300, 200)), secondary tags grow around them when selected.
Nodes are draggable, with positions saved on zone switch.
3. Node Selection
Description: Users can select parent and secondary tags, indicated by a green color (#4CAF50).
Implementation:
tagStore.toggleTag(id) toggles selected state.
ForceGraph.vue updates fill in updateNodes based on selected.
Behavior: Selection persists across zone switches, visually updated in real-time.
4. State Persistence
Description: Node positions (x, y) and selections (selected) persist when switching zones.
Implementation:
ForceGraph.vue emits nodePositionsUpdated on unmount, sending { id, x, y }.
TagCloud.vue updates tagStore.tags with these positions.
Behavior: Nodes retain their last dragged positions and selection state.

Core Implementation Details
tagStore.ts
State:
tags: Flat array of all tags (parents and secondaries), with x, y, selected.
zones: Array of zone names (e.g., ["Subject"]).
focusedZone: Current zone (e.g., "Subject").

Actions:
setFocusedZone(zone): Switches zones without resetting state.
toggleTag(id): Toggles selected, deselects other parents if a parent is clicked.
Getters:
graphNodes: Returns parent tags or selected parent + secondary tags.
graphLinks: Links from selected parent to its secondary tags.
ForceGraph.vue
Props: width, height, nodes, links.
Emits: 
nodeClick(id): Fired on node click.
nodePositionsUpdated(positions): Fired on unmount with { id, x, y }[].
Key Functions:
initializeGraph: Sets up SVG, simulation, and initial positions.
updateGraph: Updates simulation with pinned parent and secondary tag positions.
updateNodes: Renders nodes, applies selected color.
saveNodePositions: Emits updated positions.
TagCloud.vue
Computed: focusedZone, zones, graphNodes, graphLinks from tagStore.
Handlers:
handleNodeClick: Calls toggleTag.
switchToZone: Calls setFocusedZone.
handleNodePositionsUpdated: Updates tagStore.tags with positions.

Potential Issues
Simulation Instability:
Cause: Strong forces (e.g., charge, center) or low velocityDecay can make nodes fly off-canvas.
Fix: Keep forces minimal (charge: -20, center.strength: 0.05, velocityDecay: 0.8) and pin nodes initially.
Reactivity Loops:
Cause: D3 updating x and y in props.nodes triggers Vue’s watch, restarting the simulation.
Fix: Watch only structural/state changes (id, text, size, selected), not x/y.
Secondary Tag Positioning:
Cause: Undefined x/y for secondary tags causes erratic parent movement.
Fix: Set secondary tags’ initial x/y to the parent’s position in updateGraph.
Performance with Many Nodes:
Cause: Large numbers of nodes/links slow D3 rendering.
Fix: Optimize updateNodes (e.g., batch updates), consider throttling simulation ticks.
No-No Hints (Avoid These Pitfalls)
Don’t Use Store in ForceGraph.vue:
Why: Breaks modularity; ForceGraph should be a dumb component using only props and emits.
Do: Emit events (e.g., nodePositionsUpdated) and let the parent (TagCloud.vue) update the store.
Don’t Mutate props.nodes Reactively Without Control:
Why: D3’s simulation updates x and y, triggering Vue watchers and causing infinite loops.
Do: Watch only non-positional properties or use a throttle/debounce if position updates are needed.
Don’t Clone Nodes Unnecessarily:
Why: Cloning breaks D3’s reference to node objects, resetting positions or causing sync issues.
Do: Use props.nodes directly and manage positions via emits.
Don’t Overpower Simulation Forces:
Why: Strong charge or center forces make nodes fly unpredictably.
Do: Use minimal forces (charge: -20, center: 0.05) and pin key nodes with fx/fy.
Don’t Skip Position Saving:
Why: Without saveNodePositions, x and y reset on zone switches.
Do: Always emit positions on unmount and update the store.

Future Expansion
Planned Features
Dynamic Tags:
Fetch secondary tags from a server on parent click.
Add isLoading to Tag for a flashing state during fetch.
Hybrid Tags:
Create a new tag combining two selected tags (e.g., Adult Male + Mammals).
Add to graphNodes with links to parents.
Node Enhancements:
Icons: Add <image> in <g> via icon property.
Dropdown Menus: Emit showMenu on right-click, render in TagCloud.vue.
Foundation Readiness
Robust: Handles selected, positions, and basic structure.
Extensible: Tag interface and updateNodes support new properties (e.g., isLoading, icon).
Modular: ForceGraph.vue stays agnostic, ready for new emits or props.
Testing Checklist
Initial Load: Parent nodes start at (300, 200) and stabilize.
Parent Selection: Click a parent → Stays put, secondary tags grow around it, turns green.
Secondary Selection: Click a secondary tag → Turns green, state persists.
Zone Switch: Switch zones → Positions and selections persist.
No Loops: Console logs only on clicks/switches, not ticks.

================
File: tailwind.config.js
================
import PrimeUI from 'tailwindcss-primeui';
module.exports = {
    content: [
      // Specify the paths to all of your template files
      "./components/**/*.{vue,js,ts}",
      "./layouts/**/*.vue",
      "./pages/**/*.vue",
      "./plugins/**/*.{js,ts}",
      "./nuxt.config.{js,ts}",
      "./node_modules/flowbite/**/*.js" // Include Flowbite's JavaScript files
    ],
    theme: {
      extend: {
        // Extend your theme here if needed
      },
    },
    plugins: [PrimeUI],
  }

================
File: tsconfig.json
================
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "extends": "./.nuxt/tsconfig.json"
}



================================================================
End of Codebase
================================================================
